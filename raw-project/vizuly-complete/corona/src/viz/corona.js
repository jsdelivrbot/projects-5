/*
 Copyright (c) 2016, BrightPoint Consulting, Inc.

 This source code is covered under the following license: http://vizuly.io/commercial-license/

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
 THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS
 OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// @version 1.1.44

//
// This is the base component for a vizuly corona chart
//
vizuly.viz.corona = function (parent) {

    // This is the object that provides pseudo "protected" properties that the vizuly.viz function helps create
    var scope={};

    var properties = {
        "data" : null,                          //Expects array of data - assumes identical length and xScale values;
        "layout" :
            vizuly.viz.layout.OVERLAP,    // STACKED, OVERLAP
        "margin": {                             // Our margin object
            "top": "7%",                        // Top margin
            "bottom": "7%",                     // Bottom margin
            "left": "8%",                       // Left margin
            "right": "7%"                       // Right margin
        },
        "duration": 500,                        // This the time in ms used for any component generated transitions
        "width": 300,                           // Overall width of component
        "height": 300,                          // Height of component
        "innerRadius" : 50,                     // Inner radius of corona
        "outerRadius" : 150,                    // Outer radius of corona
        "radiusScale" : d3.scale.linear(),      // Radius scale (defaults to linear)
        "y" : null,                             // Function to return 'y' value - cartesian y translates to distance from center in polar coordinates.
        "x": null,                              // Function to return 'x' value - cartesian x translates to the angle from 0 degrees around the center of corona.
        "yAxis" : d3.svg.axis(),                // Axis shown along perimeter of the corona
        "xAxis" : d3.svg.axis(),                // Axis shown radiating out from center of corona
        "thetaScale" : "undefined",             // The scale to determine the distribution of angles around the center for each 'x' plot
        "interpolate" : "linear-closed"         // Used to determine vertex type of lines
    };

    //Create our viz and type it
    var viz=vizuly.component.create(parent,scope,properties);
    viz.type="viz.chart.corona";

    // Measurements

    var size;                           // Holds the 'size' variable as defined in viz.util.size()
    var tipRadius;                      // radius of each hit circle
    var xAxisTickStep;                  // The number of data points between each xAxis tick
    var xAxisTickData;                  // Holds the ticks generated by the d3.axis
    var stack;                          // used for the stacking layout for the lines and area

    var line = d3.svg.line.radial();    // d3 line path generator for our RADIAL lines
    var area = d3.svg.area.radial();    // d3 area path generator for our RADIAL areas

    //These are all d3.selection objects we use to insert and update svg elements into
    var svg,g,xAxisPlot, yAxisPlot, plot, background, plotBackground, series, defs, pointHitArea;

    initialize();

    // Here we set up all of our svg layout elements using a 'vz-XX' class namespace.  This routine is only called once
    // These are all place holder groups for the individual data driven display elements.   We use these to do general
    // sizing and margin layout.  The all are referenced as D3 selections.
    function initialize() {

        svg = scope.selection.append("svg").attr("id", scope.id).style("overflow","visible").attr("class","vizuly");
        background = svg.append("rect").attr("class","vz-background");
        defs = vizuly.util.getDefs(viz);
        g = svg.append("g").attr("class","vz-corona-viz");
        xAxisPlot = g.append("g").attr("class","vz-xAxis-plot");
        yAxisPlot = g.append("g").attr("class","vz-yAxis-plot");
        plot = g.append("g").attr("class","vz-plot").attr("clip-path","url(#" + scope.id + "_plotClipPath)");
        plotBackground = plot.append("rect").attr("class","vz-plot-background");
        series = plot.append("g").attr("class","vz-series");
        pointHitArea = g.append("g").attr("class","vz-point-areas");

        // Make sure we have a default tick format - as we need to use these for our layout
        scope.yAxis.tickFormat(function (d) { return d});
        scope.xAxis.tickFormat(function (d) { return d});

        // Tell everyone we are done initializing.
        scope.dispatch.initialize();
    }

    // The measure function performs any measurement or layout calcuations prior to making any updates to the SVG elements
    function measure() {

        // Call our validate routine and make sure all component properties have been set
        viz.validate();

        // Get our size based on height, width, and margin
        size = vizuly.util.size(scope.margin, scope.width, scope.height);

        // Calculate our tick step based on number of ticks we have and length of data.
        xAxisTickStep = Math.round(scope.data[0].length/scope.xAxis.ticks()[0]);

        // Use the d3 axis to create out own dummy tick data so we can use it later.
        xAxisTickData = function () { var a=[]; for (var i=0; i < scope.xAxis.ticks()[0] ; i++) {a.push(i)} return a}.apply(this);

        // This is the offset to use for the stack algorithm
        var offset = (scope.layout == vizuly.viz.layout.STACKED) ? "reverse" :  "none";

        // Set the properites of our stack layout
        stack = d3.layout.stack()
            .values(function(d) { return d; })
            .x(function(d) { return String(scope.x(d)); })
            .y(function(d) { return scope.y(d); })
            .out(function(d, y0, y) {d.y0 = (offset == "none" ) ? 0 : y0; d.y=y; })
            .order("reverse")
            .offset(offset);

        // Stack our data
        stack(scope.data);

        // Set our theta scale and range (or range bands) depending on scale type.
        if (scope.thetaScale == "undefined") {
            var scale;
            if (typeof viz.x()(scope.data[0][0]) == "string") {
                scale = d3.scale.ordinal();
                scale.rangeBands([0,2 * Math.PI]);
            }
            else if (viz.x()(scope.data[0][0]) instanceof Date) {
                scale = d3.time.scale();
                scale.range([0,2 * Math.PI]);
            }
            else {
                //scale = d3.scale.ordinal();
                scale= d3.scale.linear();
                scale.range([0,2 * Math.PI]);
            }
            scope.thetaScale = scale;
        }

        // Set theta scale domain - see if it is ordinal and map values, otherwise assume min/max is good enough.
        if (typeof viz.x()(scope.data[0][0]) == "string") {
            scope.thetaScale.domain(scope.data[0].map(function (d) { return scope.x(d); }));
        }
        else {
            scope.thetaScale.domain([d3.min(scope.data[0], function (d) { return scope.x(d); }), d3.max(scope.data[0], function (d) { return scope.x(d); })]);
        }

        // Set our radius scale range
        scope.radiusScale.range([scope.innerRadius, scope.outerRadius]);

        // Set our radius scale domain based on the data values
        scope.radiusScale.domain([ 0, d3.max(scope.data, function (data) { return d3.max(data, function (d) { return Number(scope.y(d) + d.y0); })})]);

        // Set our area path generator properties
        area.interpolate(scope.interpolate)
            .angle(function(d) { return scope.thetaScale(scope.x(d)); })
            .innerRadius(function(d,i) { return scope.radiusScale(d.y0); })
            .outerRadius(function(d,i) { return scope.radiusScale(scope.y(d) +  d.y0); });

        // Set our line path generator properties
        line.interpolate(scope.interpolate)
            .angle(function(d) { return scope.thetaScale(scope.x(d)); })
            .radius(function(d,i) { return scope.radiusScale(scope.y(d) + d.y0); });

        // Orient our yAxis scale
        scope.yAxis.scale(scope.radiusScale).orient("left");

        // Measure the tipRadius (used to detect interaction events)
        tipRadius = Math.min(size.width/50,size.height/50);

        // Tell everyone we are done measuring.
        scope.dispatch.measure();

    }

    // The update function is the primary function that is called when we want to render the visualiation based on
    // all of its set properties.  A developer can change propertys of the components and it will not show on the screen
    // until the update function is called
    function update() {

        // Call measure each time before we update to make sure all our our layout properties are set correctly
        measure();

        // Layout all of our primary SVG d3 elements.
        svg.attr("width", scope.width).attr("height", scope.height);
        background.attr("width", scope.width).attr("height", scope.height);
        plot.style("width",size.width).style("height",size.height).attr("transform","translate(" + (size.left + size.width/2)  + "," + (size.top + size.height/2) +  ")");
        pointHitArea.style("width",size.width).style("height",size.height).attr("transform","translate(" + size.left + "," + size.top +  ")");
        xAxisPlot.attr("transform","translate(" + (size.left + size.width/2)  + "," + (size.height/2 + size.top + 3) + ")");
        yAxisPlot.attr("transform","translate(" + (size.left + size.width/2)  + "," + (size.height/2 + size.top + 3) + ")");
        plotBackground.attr("width",size.width).attr("height",size.height);

        // Use select, enter, exit to create our series plots
        // Each series is a group which contains its own set of plots
        var seriesPlots = series.selectAll(".vz-series-plots").data(scope.data);
        seriesPlots.enter().append("g").attr("class", "vz-series-plots");
        seriesPlots.exit().remove();

        // Create our line and area paths for each series.
        seriesPlots.each(function (d,j) {
            var series = d3.select(this);

            var linePath = series.selectAll(".vz-line").data([d]);
            linePath.enter().append("path").attr("class", "vz-line");
            linePath.exit().remove();
            linePath.transition().duration(scope.duration).attr("d", function (d,j) {
                return line(d);
            });
            var areaPath = series.selectAll(".vz-area").data([d]);
            areaPath.enter().append("path").attr("class", "vz-area");
            areaPath.exit().remove();
            areaPath.transition().duration(scope.duration).attr("d", function (d,j) {
                return area(d);
            });
        });

        // Remove any point hit areas - we make new ones each time.
        pointHitArea.selectAll(".vz-tip").remove();

        // For EVERY data point across all series we are going to create a svg.g group and put a circle in it
        // The circle in it will have a very small (.001) opacity and be used to capture mouse events for
        // each data point
        // If you need to optimize this chart for performance you should consider removing these elements, it will
        // greatly speed up the rendering time and responsiveness of the chart
        scope.data.forEach(function (series,j) {
            var  points = pointHitArea.selectAll("vz-tip").data(series).enter()
                .append("g").attr("class", "vz-tip")
                .attr("transform", function (d,i) {
                    var point = cartesianToPolar(scope.y(d) + d.y0,scope.x(d));
                    return "translate(" + point.x + "," + point.y  + ")" })
                .on("mouseover", function (d,i) { scope.dispatch.mouseover.apply(this,[d,i,j]); })
                .on("touchstart", function (d,i) { scope.dispatch.mouseover.apply(this,[d,i,j]); })
                .on("mouseout", function (d,i) { scope.dispatch.mouseout.apply(this,[d,i,j]); })
                .on("mousedown", function (d,i) { scope.dispatch.mousedown.apply(this,[d,i,j]);});

            points.each(function () {
                var tip =  d3.select(this);
                tip.append("circle")
                    .attr("class","vz-hit-circle")
                    .style("fill", "#0f2747")
                    .style("stroke",null)
                    .style("opacity", .001)
                    .transition()
                    .attr("r", tipRadius);
            });

        });

        // We use these arc paths so labels can be created along each radial curve for the x axis
        defs.selectAll(".vz-x-axis-arc-path").remove();
        defs.selectAll(".vz-x-axis-arc-path")
            .data(xAxisTickData)
            .enter()
            .append("path")
            .attr("class","vz-x-axis-arc-path")
            .attr("id", function (d,i) { return scope.id + "_x_text_arc_" + i;})
            .attr("d",function (d,i) { return vizuly.svg.text.arcPath(scope.outerRadius *1.05, scope.thetaScale(scope.x(scope.data[0][i*xAxisTickStep]))); });



        // Create xAxis Labels using the def arc paths we created above
        xAxisPlot.selectAll(".vz-radial-x-axis-tick").remove();
        xAxisPlot.selectAll(".vz-radial-x-axis-tick")
            .data(xAxisTickData)
            .enter().append("g")
            .attr("class", "vz-radial-x-axis-tick")
            .append("text")
            .append("textPath")
            .attr("text-anchor","middle")
            .attr("startOffset","50%")
            .style("overflow","visible")
            .attr("xlink:href",  function (d,i) { return "#" + scope.id + "_x_text_arc_" + i;})
            .text(function(d,i) { return scope.xAxis.tickFormat()(scope.x(scope.data[0][i*xAxisTickStep])); })


        // Create yAxis label placeholders - a little hack to have D3 figure out the best axis lines.
        yAxisPlot.selectAll(".vz-label-ticks").remove();
        yAxisPlot.append("g")
            .attr("class","vz-label-ticks")
            .style("display","none")
            .call(scope.yAxis)


        // Now lets get our ticks to create our circles
        yAxisPlot.selectAll(".vz-y-axis-tick").remove();
        var ticks = yAxisPlot.selectAll(".tick")[0].map(function (d) { return d3.select(d).datum()});
        yAxisPlot.selectAll(".vz-y-axis-tick")
            .data(ticks).enter()
            .append("circle").attr("class","vz-y-axis-tick")
            .attr("cx",0)
            .attr("cy",0)
            .attr("r",function (d) { return scope.radiusScale(d)})
            .style("fill","none");

        // Create our yAxis labels
        defs.selectAll(".vz-y-axis-arc-path").remove();
        yAxisPlot.selectAll(".vz-y-axis-tick-label").remove();
        ticks.forEach(function (tick,j) {
            // We use these arc paths so labels can be created along each radial curve for the x axis
            defs.append("path")
                .attr("class","vz-y-axis-arc-path")
                .attr("id", function (d,i) { return scope.id + "_y_text_arc_" + j + "_" + i ;})
                .attr("d",function () {
                    return vizuly.svg.text.arcPath(scope.radiusScale(tick)*1.02,0)});
            // Attach our yAxis labels and refernece the path def above.
            yAxisPlot.append("text")
                .attr("class","vz-y-axis-tick-label")
                .append("textPath")
                .attr("text-anchor","middle")
                .attr("startOffset","50%")
                .style("overflow","visible")
                .attr("xlink:href",  function (d,i) { return "#" + scope.id + "_y_text_arc_" + j + "_" + i;})
                .text(function() {
                    return scope.yAxis.tickFormat()(tick); })
        });

        // Let everyone know we are done updating.
        scope.dispatch.update();

    }

    // Used to translate from cartesian coordinates to polar coordinates.
    function cartesianToPolar(x,y) {
        var r = scope.radiusScale(x);
        var a = scope.thetaScale(y) - Math.PI/2;
        x = r * Math.cos(a) + size.width/2;
        y = r * Math.sin(a) + size.height/2;
        return ({x:x,y:y});

    }

    // This is our public update call that all viz components implement
    viz.update = function () {
        update();
        return viz;
    };

    // Returns our glorious viz component :)
    return viz;

};